# TSBS Supplemental Guide: QuestDB

QuestDB is a high-performance open-source time series database with SQL as a
query language with time-oriented extensions. QuestDB implements PostgreSQL wire
protocol, a REST API, and supports ingestion using InfluxDB line protocol.

This guide is provided as supplementary documentation for the
[Time Series Benchmark Suite](https://github.com/timescale/tsbs) (TSBS) used to
benchmark several time series databases. This document explains how the data for
TSBS is generated along with additional flags available when using the data
importer (`tsbs_load_questdb`). This guide should be read _after_ the
[TSBS README](https://github.com/timescale/tsbs/blob/master/README.md).

## Data format

Data generated by `tsbs_generate_data` is in InfluxDB line protocol format where
each reading is composed of the following:

- the table name followed by a comma
- several comma-separated items of tags in the format `<label>=<value>` followed
  by a space
- several comma-separated items of fields in the format `<label>=<value>`
  followed by a space
- a timestamp for the record
- a newline character `\n`

An example reading from the `iot` use case looks like the following:

```text
diagnostics,name=truck_3985,fleet=West,driver=Seth,model=H-2,device_version=v1.5 load_capacity=1500,fuel_capacity=150,nominal_fuel_consumption=12,fuel_state=0.8,current_load=482,status=4i 1451609990000000000
```

## `tsbs_load_questdb` flags

**`--batch-size`** (type: `uint`, default: `10000`)

Number of items to batch together in a single insert.

**`--db-name`** (type: `string`, default: `benchmark`)

Name of database.

**`--do-abort-on-exist`** (type: `boolean`, default: `false`)

Whether to abort if a database with the given name already exists.

**`--do-create-db`** (type: `boolean`, default: `true`)

Whether to create the database. Disable on all but one client if running on a
multi-client setup.

**`--do-load`** (type: `boolean`, default: `true`)

Whether to write data. Set this flag to false to check input read speed.

**`--file`** (type: `string`, default: none)

File name to read data from.

**`--ilp-bind-to`** (type: `string`, default `127.0.0.1:9009`)

QuestDB InfluxDB line protocol TCP port in the format `<ip>:<port>`

**`--limit`** (type: `uint`, default: `0`)

Number of items to insert where `0` is all items.

**`--reporting-period`** (type: `duration`, default: `10`)

Period in seconds to report write stats

**`--seed`** (type: `int`, default: `0`)

PRNG seed. The default value of `0` uses the current timestamp as a seed.

**`--url`** (type: `string`, default: `http://localhost:9000/`)

QuestDB REST end point.

**`--workers`** (type: `uint`, default: `1`)

Number of parallel clients inserting.

**`-help`**

Prints available flags with defaults:

```bash
~/tmp/go/bin/tsbs_load_questdb -help
```

## How to run the test (FreeBSD example)

Firstly, install and build the benchmark suite

### Set up TSBS

Create a temporary directory for the Go binaries

```bash
mkdir -p ~/tmp/go/src/github.com/timescale/
cd ~/tmp/go/src/github.com/timescale/
```

Clone the TSBS repository, build test and install Go binaries:

```bash
git clone git@github.com:questdb/tsbs.git
cd ~/tmp/go/src/github.com/timescale/tsbs/ && git checkout questdb-tsbs-load
GOPATH=~/tmp/go go build -v ./...
GOPATH=~/tmp/go go test -v github.com/timescale/tsbs/cmd/tsbs_load_questdb
GOPATH=~/tmp/go go install -v ./...
```

### Generating data

Data is generated using the `influx` format. To generate a small dataset for
quick benchmarks:

```bash
~/tmp/go/bin/tsbs_generate_data \
--use-case="iot" --seed=123 --scale=4000 \
--timestamp-start="2016-01-01T00:00:00Z" --timestamp-end="2016-01-01T01:00:00Z" \
--log-interval="10s" --format="influx" > /tmp/data
```

To generate a full data set for more intensive benchmarks:

```bash
~/tmp/go/bin/tsbs_generate_data \
--use-case="iot" --seed=123 --scale=4000 \
--timestamp-start="2016-01-01T00:00:00Z" --timestamp-end="2016-01-04T00:00:00Z" \
--log-interval="10s" --format="influx" > /tmp/data
```

### Running the benchmark tool

Generated data can be loaded directly using the tool:

```bash
cat /tmp/data | ~/tmp/go/bin/tsbs_load_questdb
```

Alternatively, shell scripts are provided which can be used to generate and load
data:

```bash
cd ~/tmp/go/src/github.com/timescale/

# generates data file /tmp/bulk_data/influx-data.gz
PATH=${PATH}:~/tmp/go/bin FORMATS=influx TS_END=2016-01-01T02:00:00Z bash ./scripts/generate_data.sh
# load data into QuestDB
PATH=${PATH}:~/tmp/go/bin NUM_WORKERS=1 ./scripts/load/load_questdb.sh
```

### Query benchmarks for iot data set (single-groupby-5-8-1 type)

Queries are generated using the `questdb` format.

**single-groupby-5-8-1:**

The dataset used to run the queries is created with the following commands for
`single-groupby-5-8-1`:

```bash
cd ~/tmp/go/src/github.com/timescale/

~/tmp/go/bin/tsbs_generate_queries \
--use-case="cpu-only" --seed=123 --scale=4000 \
--timestamp-start="2016-01-01T00:00:00Z" --timestamp-end="2016-01-02T00:00:01Z" \
--queries=1000 --query-type="single-groupby-5-8-1" \
--format="questdb" > /tmp/queries_questdb

~/tmp/go/bin/tsbs_run_queries_questdb --file /tmp/queries_questdb --print-interval 500
```

### Query benchmarks for iot data set (high-cpu-1 use case)

Queries are generated using the `questdb` format.

**high-cpu-1:**

The dataset used to run the queries is created with the following commands for
`high-cpu-1`:

```bash
cd ~/tmp/go/src/github.com/timescale/

~/tmp/go/bin/tsbs_generate_queries \
--use-case="cpu-only" --seed=123 --scale=4000 \
--timestamp-start="2016-01-01T00:00:00Z" --timestamp-end="2016-01-02T00:00:01Z" \
--queries=1000 --query-type="high-cpu-1" --format="questdb" > /tmp/queries_questdb

~/tmp/go/bin/tsbs_run_queries_questdb --file /tmp/queries_questdb --print-interval 500
```

### Query benchmark shell scripts

Additionally, shell scripts are provided which can be used to generate and run
the queries:

```bash
cd ~/tmp/go/src/github.com/timescale/
PATH=${PATH}:~/tmp/go/bin FORMATS=questdb TS_END=2016-01-02T00:00:00Z bash ./scripts/generate_queries.sh
PATH=${PATH}:~/tmp/go/bin ./scripts/run_queries/run_queries_questdb.sh
```

**Queries generated:**

```sql
-- high-cpu-1
SELECT *
FROM cpu
WHERE usage_user > 90.0
 AND hostname IN ('host_249')
 AND timestamp >= '2016-01-01T07:47:52Z'
 AND timestamp < '2016-01-01T19:47:52Z

-- high-cpu-all
SELECT *
FROM cpu
WHERE usage_user > 90.0
 AND timestamp >= '2016-01-01T07:47:52Z'
 AND timestamp < '2016-01-01T19:47:52Z'

-- cpu-max-all-1
SELECT
 hour(timestamp) AS hour,
 max(usage_user) AS max_usage_user, max(usage_system) AS max_usage_system, max(usage_idle) AS max_usage_idle, max(usage_nice) AS max_usage_nice, max(usage_iowait) AS max_usage_iowait, max(usage_irq) AS max_usage_irq, max(usage_softirq) AS max_usage_softirq, max(usage_steal) AS max_usage_steal, max(usage_guest) AS max_usage_guest, max(usage_guest_nice) AS max_usage_guest_nice
FROM cpu
WHERE hostname IN ('host_249')
 AND timestamp >= '2016-01-01T08:24:59Z'
 AND timestamp < '2016-01-01T16:24:59Z'
 SAMPLE BY 1h

-- cpu-max-all-8
SELECT
 hour(timestamp) AS hour,
 max(usage_user) AS max_usage_user, max(usage_system) AS max_usage_system, max(usage_idle) AS max_usage_idle, max(usage_nice) AS max_usage_nice, max(usage_iowait) AS max_usage_iowait, max(usage_irq) AS max_usage_irq, max(usage_softirq) AS max_usage_softirq, max(usage_steal) AS max_usage_steal, max(usage_guest) AS max_usage_guest, max(usage_guest_nice) AS max_usage_guest_nice
FROM cpu
WHERE hostname IN ('host_249', 'host_1403', 'host_1435', 'host_3539', 'host_3639', 'host_3075', 'host_815', 'host_2121')
 AND timestamp >= '2016-01-01T08:24:59Z'
 AND timestamp < '2016-01-01T16:24:59Z'
 SAMPLE BY 1h

-- double-groupby-1
SELECT timestamp, hostname,
 avg(usage_user) AS avg_usage_user
FROM cpu
WHERE timestamp >= '2016-01-01T07:47:52Z'
 AND timestamp < '2016-01-01T19:47:52Z'
 SAMPLE BY 1h
 GROUP BY timestamp, hostname

-- double-groupby-5
SELECT timestamp, hostname,
 avg(usage_user) AS avg_usage_user, avg(usage_system) AS avg_usage_system, avg(usage_idle) AS avg_usage_idle, avg(usage_nice) AS avg_usage_nice, avg(usage_iowait) AS avg_usage_iowait
FROM cpu
WHERE timestamp >= '2016-01-01T07:47:52Z'
 AND timestamp < '2016-01-01T19:47:52Z'
 SAMPLE BY 1h
 GROUP BY timestamp, hostname

-- double-groupby-all
SELECT timestamp, hostname,
 avg(usage_user) AS avg_usage_user, avg(usage_system) AS avg_usage_system, avg(usage_idle) AS avg_usage_idle, avg(usage_nice) AS avg_usage_nice, avg(usage_iowait) AS avg_usage_iowait, avg(usage_irq) AS avg_usage_irq, avg(usage_softirq) AS avg_usage_softirq, avg(usage_steal) AS avg_usage_steal, avg(usage_guest) AS avg_usage_guest, avg(usage_guest_nice) AS avg_usage_guest_nice
FROM cpu
WHERE timestamp >= '2016-01-01T10:20:52Z'
 AND timestamp < '2016-01-01T22:20:52Z'
 SAMPLE BY 1h
 GROUP BY timestamp, hostname

-- groupby-orderby-limit
SELECT timestamp AS minute,
 max(usage_user)
FROM cpu
WHERE timestamp < '2016-01-01T03:17:08Z'
 SAMPLE BY 1m
 LIMIT 5

-- lastpoint
SELECT * FROM cpu latest by hostname

-- single-groupby-1-1-12
SELECT timestamp,
 max(usage_user) AS max_usage_user
FROM cpu
WHERE hostname IN ('host_249')
 AND timestamp >= '2016-01-01T07:47:52Z'
 AND timestamp < '2016-01-01T19:47:52Z'
 SAMPLE BY 1m

-- single-groupby-1-8-1
SELECT timestamp,
 max(usage_user) AS max_usage_user
FROM cpu
WHERE hostname IN ('host_249', 'host_1403', 'host_1435', 'host_3539', 'host_3639', 'host_3075', 'host_815', 'host_2121')
 AND timestamp >= '2016-01-01T02:17:08Z'
 AND timestamp < '2016-01-01T03:17:08Z'
 SAMPLE BY 1m
```
